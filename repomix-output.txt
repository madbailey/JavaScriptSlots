This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-13T17:59:10.866Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
index.html
package.json
README.md
src/scripts/game.js
src/scripts/gameSymbol.js
src/scripts/grid.js
src/scripts/main.js
src/scripts/player.js
src/scripts/symbol_list.js
src/styles/slotmachine.css

================================================================
Files
================================================================

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Slot Machine</title>
    <link rel="stylesheet" href="src/styles/slotmachine.css">
</head>
<body>
    <div class="slot-machine">
        <div class="reels" id="reelsContainer"></div>
        <div class="button-container">
            <button id="spinButton" onclick="startSpin()">Spin</button>
        </div>
          <!-- Status Bar -->
        <div id="statusBar" class="status-bar">
            <span id="moneyDisplay">Money: 25</span>
            <span id="rentDisplay">Rent Due: 50</span>
            <span id="spinsRemainingDisplay">Spins Remaining: 15</span>
        </div>

        <div id="resultDisplay">Press Spin to Start!</div>
         <!-- Symbol Choices (Initially Hidden) -->
        <div id="symbolChoices" style="display: none;">
            <h2>Choose a Symbol:</h2>
            <!-- Buttons will be added dynamically here -->
        </div>
    </div>


    <script type="module" src="src/scripts/gameSymbol.js"></script>
    <script type="module" src="src/scripts/player.js"></script>
    <script type="module" src="src/scripts/grid.js"></script>
    <script type="module" src="src/scripts/game.js"></script>
    <script type="module" src="src/scripts/main.js"></script>

    <script>
        const reelsContainer = document.getElementById('reelsContainer');
        const gridHTML = Array.from({ length: 4 }, (_, row) =>
            Array.from({ length: 5 }, (_, col) =>
                `<div class="reel" id="reel${row}${col}">
                    <div class="reel-content">
                        <span class="symbol">?</span>
                        <span class="payout" style="display:none;">+0</span>
                    </div>
                </div>`
            ).join('')
        ).join('');
        reelsContainer.innerHTML = gridHTML;
    </script>


</body>
</html>

================
File: package.json
================
{
  "name": "javascripttut",
  "version": "1.0.0",
  "description": "",
  "main": "project.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "prompt-sync": "^4.2.0"
  }
}

================
File: README.md
================
Java Script Slots is a simple dynamic slot machine based off the game luck by a landlord. The game contains complex symbol interaction, for example - cat symbols will drink adjacent milk symbols. Skull symbols pay out 0 base, but pay out an additional 1 per existing skull.

================
File: src/scripts/game.js
================
// src/scripts/game.js
import Grid from './grid.js';
import Player from './player.js';
import symbols from './symbol_list.js';  // Import the symbols

const GameState = {
    WAITING: 'waiting',
    SPINNING: 'spinning',
    SCORING: 'scoring',
    RESULT: 'result',
    ADD_SYMBOL: 'add_symbol',
    GAME_OVER: 'game_over' // Add a game over state
};

class Game {
    constructor(player) {
        this.grid = new Grid(4, 5, player);
        this.player = player;
        this.state = GameState.WAITING;
        this.rentDue = 50;  // Initial rent
        this.rentIncrease = 25; // Rent increases by this much each time
        this.spinsRemaining = 15; // Number of spins before rent is due
        this.currentSpin = 0;
    }

    start() {
        console.log('Game started');
        this.setState(GameState.WAITING);
        this.grid.initializeReels();
        this.updateUI(); // Add a method to update the entire UI
    }

    spin() {
        if (this.state !== GameState.WAITING) return;

        console.log('Spinning...');
        this.setState(GameState.SPINNING);
        this.grid.clearGrid();
        this.currentSpin++;
        this.grid.placeSymbols(); //place symbols before the timeout
        // Simulate spinning duration (important for visual feedback)
        setTimeout(() => {
             this.grid.calculateScores();
            this.grid.render(); // Update the grid display
            this.grid.updateReels(); //update the UI
            this.setState(GameState.SCORING);
            setTimeout(() => {
                 this.showResult();
             }, 1000); // Wait 2 second to move to result


        }, 1000);  // 2 seconds of spinning (adjust as needed)
    }


    showResult() {
        console.log('Showing result...');
        this.setState(GameState.RESULT);
        this.updateUI(); // Update money display
        this.spinsRemaining--;


         if (this.spinsRemaining <= 0) {
                this.checkRentPayment();
            } else {
                // Go to add symbol phase
                setTimeout(() => {
                  this.promptNewSymbol();
                }, 1000);
            }
    }

    promptNewSymbol() {
        console.log('Adding new symbol...');
        this.setState(GameState.ADD_SYMBOL);

        // Display symbol choices to the player.  This is *crucial*.
        this.displaySymbolChoices();

        // Player.addSymbol() will now be called *after* the player makes a choice.
    }

    waitForNextRound() {
        console.log('Waiting for next round...');
        this.setState(GameState.WAITING);
        this.updateUI();
    }


    setState(newState) {
        console.log(`Transitioning to ${newState}`);
        this.state = newState;
    }

    updateUI() {
        this.player.updateMoneyDisplay();
        document.getElementById('rentDisplay').textContent = `Rent Due: ${this.rentDue}`;
        document.getElementById('spinsRemainingDisplay').textContent = `Spins Remaining: ${this.spinsRemaining}`;
    }

    checkRentPayment() {
        if (this.player.wallet >= this.rentDue) {
            this.player.removeMoney(this.rentDue);
            this.rentDue += this.rentIncrease;
            this.spinsRemaining = 15; // Reset spins
            this.updateUI();
            this.promptNewSymbol(); // Continue the game
              // Add "rent paid" animation
              const rentDisplay = document.getElementById('rentDisplay');
              rentDisplay.classList.add('rent-paid');
              setTimeout(() => {
                  rentDisplay.classList.remove('rent-paid');
              }, 2000);
        } else {
            this.setState(GameState.GAME_OVER);
            alert("Game Over! You couldn't pay the rent.");
            // You could also offer a "restart" button here.
             // Disable spin button
             document.getElementById('spinButton').disabled = true;
        }
    }

    displaySymbolChoices() {
        const symbolChoicesContainer = document.getElementById('symbolChoices');
        symbolChoicesContainer.innerHTML = ''; // Clear previous choices

        // Get 3 random symbols
        const availableSymbols = Object.keys(symbols);
        const chosenSymbols = [];
        for (let i = 0; i < 3; i++) {
            let randomIndex = Math.floor(Math.random() * availableSymbols.length);
            chosenSymbols.push(availableSymbols[randomIndex]);
            availableSymbols.splice(randomIndex, 1);  // Remove to avoid duplicates
        }


        chosenSymbols.forEach(symbolAlias => {
            const symbol = symbols[symbolAlias];
            const button = document.createElement('button');
            button.textContent = `${symbol.unicode} (${symbol.alias}) - ${symbol.tooltip}`;
            button.onclick = () => {
                this.player.addSymbol(symbolAlias);
                symbolChoicesContainer.innerHTML = ''; // Clear choices after selection

                // ADD THIS LINE TO HIDE THE CONTAINER:
                symbolChoicesContainer.style.display = 'none';

                this.waitForNextRound();
            };
            symbolChoicesContainer.appendChild(button);
        });

          // Show the container
        symbolChoicesContainer.style.display = 'block';
    }
}

export default Game;

================
File: src/scripts/gameSymbol.js
================
class GameSymbol {
    constructor(unicode, alias, tooltip, basePayout, rarity) {
        this.unicode = unicode;
        this.alias = alias;
        this.tooltip = tooltip;
        this.basePayout = basePayout;
        this.rarity = rarity;
        this.globalEffects = [];
        this.adjacencyEffects = {};
    }

    addGlobalEffect(effectType, params) {
        this.globalEffects.push({ effectType, params });
    }

    addAdjacencyEffect(adjSymbolAlias, effectType, params) {
        this.adjacencyEffects[adjSymbolAlias] = { effectType, params };
    }

    executeInteraction(adjSymbol, grid) {
        let effect = this.adjacencyEffects[adjSymbol.alias];
        if (!effect) return;

        switch (effect.effectType) {
            case 'adjacencyDestruction':
                this.destroy(adjSymbol, grid);
                break;
            case 'adjacencyBonus':
                this.applyBonus(adjSymbol, effect.params.bonusAmount); // Correctly pass bonusAmount
                break;
            // Add more interaction types here (e.g., transformations)
            default:
                console.log("No such adjacency effect defined.");
        }
    }

    applyGlobalEffects(grid, rowIndex) { // Add rowIndex parameter
        this.globalEffects.forEach(effect => {
            switch (effect.effectType) {
                case 'totalMultiplier':
                    this.basePayout += grid.countSymbols(this.alias) * effect.params.multiplier;
                    break;
                case 'rowMultiplier':
                    // Use rowIndex, NOT effect.params.row
                    this.basePayout += grid.countSymbolsInRow(this.alias, rowIndex) * effect.params.multiplier;
                    break;
                // Add more global effect types
            }
        });
    }

    destroy(symbol, grid) {
        console.log(`${this.alias} destroys ${symbol.alias}.`); // Show who destroys whom
        this.basePayout += symbol.basePayout; // Add destroyed symbol's payout
        grid.removeSymbol(symbol);  // Remove from grid (and player inventory)
    }

    applyBonus(adjacentSymbol, bonusAmount) { // Corrected parameter name
        console.log(`Bonus applied between ${this.alias} and ${adjacentSymbol.alias}`);
        this.basePayout += bonusAmount; // Add the bonus
    }

    render() {
        return this.unicode;
    }
}

export default GameSymbol;

================
File: src/scripts/grid.js
================
// src/scripts/grid.js

import symbols from './symbol_list.js';

class Grid {
    constructor(rows, columns, player) {
        this.rows = rows;
        this.columns = columns;
        this.player = player;
        this.grid = Array.from({ length: rows }, () => Array(columns).fill(null));
    }

    placeSymbols() {
        this.clearGrid(); // Clear before placing
        let inventory = this.player.getInventorySymbols();
        let totalSlots = this.rows * this.columns;
        let symbolIndexes = [];

        // Create a shuffled array of all possible positions
        let positions = Array.from({length: totalSlots}, (_, i) => i);
        for (let i = positions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [positions[i], positions[j]] = [positions[j], positions[i]]; // Fisher-Yates shuffle
        }


         // Place symbols, handling cases where inventory is smaller than the grid
        for (let i = 0; i < Math.min(positions.length, inventory.length); i++) {
            let row = Math.floor(positions[i] / this.columns);
            let col = positions[i] % this.columns;
            this.grid[row][col] = inventory[i];
         }
    }


   calculateScores() {
        // Reset payouts before recalculating
        this.grid.forEach(row => row.forEach(symbol => {
            if (symbol) symbol.basePayout = symbols[symbol.alias].basePayout; // IMPORTANT: Reset to base
        }));

        this.applyGlobalEffects();
        this.checkInteractions();
        this.calculatePayouts(); // This should happen *after* all effects
    }

  removeSymbol(symbol) {
        for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.columns; col++) {
                if (this.grid[row][col] === symbol) {
                    this.grid[row][col] = null;  // Remove from the grid
                    this.player.removeSymbol(symbol.alias); // Remove from player inventory
                    return; // Exit after finding and removing
                }
            }
        }
    }


    countSymbols(alias) {
        let count = 0;
        for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.columns; col++) {
                if (this.grid[row][col] && this.grid[row][col].alias === alias) {
                    count++;
                }
            }
        }
        return count;
    }

    countSymbolsInRow(alias, row) {
        if (typeof row === "undefined" || row < 0 || row >= this.rows) {
            console.error("Invalid row index:", row);
            return 0;
        }

        let count = 0;
        if (this.grid[row]) {
            this.grid[row].forEach(symbol => {
                if (symbol && symbol.alias === alias) {
                    count++;
                }
            });
        } else {
            console.error("No such row exists in the grid:", row);
        }
        return count;
    }

    applyGlobalEffects() {
        this.grid.forEach((row, rowIndex) => { // Get rowIndex here
            row.forEach(symbol => {
                if (symbol) {
                    symbol.applyGlobalEffects(this, rowIndex); // Pass rowIndex
                }
            });
        });
    }

  clearGrid() {
        this.grid = Array.from({ length: this.rows }, () => Array(this.columns).fill(null));
    }

   checkInteractions() {
        for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.columns; col++) {
                const currentSymbol = this.grid[row][col];
                if (currentSymbol) {
                    this.checkAdjacentSymbols(row, col, currentSymbol);  //Pass current symbol
                }
            }
        }
    }

   checkAdjacentSymbols(row, col, currentSymbol) { //Added current symbol
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

        directions.forEach(([dRow, dCol]) => {
            let adjRow = row + dRow;
            let adjCol = col + dCol;

            if (adjRow >= 0 && adjRow < this.rows && adjCol >= 0 && adjCol < this.columns) {
                let adjSymbol = this.grid[adjRow][adjCol];
                if (adjSymbol) {
                    // Use the currentSymbol for the interaction.
                    currentSymbol.executeInteraction(adjSymbol, this);
                }
            }
        });
    }


    calculatePayouts() {
        let totalPayout = 0;
        this.payoutsThisRound = []; // ADD THIS: Store individual payouts

        this.grid.forEach((row, rowIndex) => {
            row.forEach((symbol, colIndex) => {
                if (symbol) {
                    const payout = symbol.basePayout;
                    totalPayout += payout;

                    // RECORD THE PAYOUT:
                    this.payoutsThisRound.push({
                        row: rowIndex,
                        col: colIndex,
                        amount: payout,
                        symbol: symbol // Optionally store the symbol itself
                    });
                    console.log(`Symbol ${symbol.alias} payout: ${symbol.basePayout}`); // Debugging
                }
            });
        });

        this.player.addMoney(totalPayout);
        console.log(`Total payout this round: ${totalPayout}`);
    }

    // Render the grid for display (console-based, for debugging)
    render() {
        return this.grid.map(row => row.map(symbol => symbol ? symbol.render() : ' ').join(' ')).join('\n');
    }

    initializeReels() {
        for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.columns; col++) {
                const reelId = `reel${row}${col}`;
                const reelElement = document.getElementById(reelId);
                if (reelElement) {
                     const symbolElement = reelElement.querySelector('.symbol');
                    const payoutElement = reelElement.querySelector('.payout');

                    if (this.grid[row][col]) {
                      symbolElement.textContent = this.grid[row][col].unicode;
                    }
                    else {
                      symbolElement.textContent = '?';
                    }
                    payoutElement.style.display = 'none';
                }
            }
        }
    }

     updateReels() {
        for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.columns; col++) {
                const reelId = `reel${row}${col}`;
                const reelElement = document.getElementById(reelId);

                if (reelElement) {
                    const symbolElement = reelElement.querySelector('.symbol');
                    const payoutElement = reelElement.querySelector('.payout'); // Keep for compatibility

                    if (this.grid[row][col]) {
                        const symbol = this.grid[row][col];
                        symbolElement.textContent = symbol.unicode;

                        // --- Animation Logic ---

                       // 2. Check for interactions (destruction, bonus, etc.)
                        //    You'll need to re-check interactions *here*
                        //    to trigger the appropriate animations.

                        // Example: Destruction animation (cat eats milk)
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        directions.forEach(([dRow, dCol]) => {
                            const adjRow = row + dRow;
                            const adjCol = col + dCol;
                            if (adjRow >= 0 && adjRow < this.rows && adjCol >= 0 && adjCol < this.columns) {
                                const adjSymbol = this.grid[adjRow][adjCol];
                                if (adjSymbol) {
                                    if (symbol.alias === 'cat' && adjSymbol.alias === 'milk') {
                                            // Add a class for the destruction animation
                                            const adjReel = document.getElementById(`reel${adjRow}${adjCol}`);
                                             if(adjReel){ //check if it exists
                                                const adjSymbolElement = adjReel.querySelector('.symbol');
                                                adjSymbolElement.classList.add('destruction');
                                                setTimeout(()=> {
                                                    adjSymbolElement.classList.remove('destruction')
                                                    adjSymbolElement.textContent = ""; //make it blank after
                                                }, 2000);
                                            }
                                    } else if (symbol.alias === 'pirate' && adjSymbol.alias === 'dog'){
                                          const adjReel = document.getElementById(`reel${adjRow}${adjCol}`);
                                             if(adjReel){ //check if it exists
                                                const adjSymbolElement = adjReel.querySelector('.symbol');
                                                adjSymbolElement.classList.add('bonus'); //bonus css class added
                                                setTimeout(()=> {
                                                    adjSymbolElement.classList.remove('bonus')
                                                }, 2000);
                                            }
                                    }
                                }
                            }
                        });


                        // --- End Animation Logic ---

                        payoutElement.style.display = 'none'; // Hide original payout

                    } else {
                        symbolElement.textContent = '?';
                         payoutElement.style.display = 'none'; // Hide if no symbol
                    }
                }
            }
        }
           // ADD THIS TO CREATE AND ANIMATE PAYOUT DIVS:
        this.animatePayouts();
    }
     animatePayouts() {
        const walletElement = document.getElementById('moneyDisplay');
        const walletRect = walletElement.getBoundingClientRect();

        this.payoutsThisRound.forEach(payoutInfo => {
            const reelElement = document.getElementById(`reel${payoutInfo.row}${payoutInfo.col}`);
            if (!reelElement) return; // Safety check

            const startRect = reelElement.getBoundingClientRect();

            // Create the floating payout element
            const payoutDiv = document.createElement('div');
            payoutDiv.className = 'floating-payout';
            payoutDiv.textContent = `+${payoutInfo.amount}`;
            document.body.appendChild(payoutDiv); // Append to body

            // Position it over the symbol
            payoutDiv.style.left = `${startRect.left + startRect.width / 2}px`;
            payoutDiv.style.top = `${startRect.top + startRect.height / 2}px`;


            // Calculate the movement needed
            const deltaX = walletRect.left - startRect.left;
            const deltaY = walletRect.top - startRect.top;

             // Apply the animation (using CSS transforms)
            payoutDiv.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(0.2)`; // Move and shrink
            payoutDiv.style.opacity = '0';

            // Remove the element after the animation
            setTimeout(() => {
                payoutDiv.remove();
            }, 2000); // Match CSS animation duration

        });
    }
}

export default Grid;

================
File: src/scripts/main.js
================
// src/scripts/main.js
import Game from './game.js';
import Player from './player.js';

const player = new Player();
const game = new Game(player);
player.setGame(game); //pass game to player

window.startSpin = function() {
    game.spin();
}

document.addEventListener('DOMContentLoaded', function() {
    game.start();
});

================
File: src/scripts/player.js
================
// player.js

import Game from "./game.js";
import GameSymbol from "./gameSymbol.js";
import symbols from './symbol_list.js';

class Player {
  constructor() {
      this.inventory = ['cat', 'cat', 'milk', 'pirate', 'dog']; // Start with some symbols
      this.wallet = 25;
      this.bonusItems = [];
      this.game = null; // Add a game property
  }
  //add this method
  setGame(gameInstance)
  {
      this.game = gameInstance;
  }

  getInventorySymbols() {
      return this.inventory.map(alias => symbols[alias]);
  }

   addSymbol(alias) {
      if (symbols[alias]) {
          this.inventory.push(alias);
          console.log(`${alias} added to inventory.  Inventory is now:`, this.inventory); // Debugging
          if (this.game) {
              this.game.updateUI();  // Call game.updateUI()
          }

      } else {
          console.error(`Symbol with alias ${alias} does not exist.`);
      }
  }

  removeSymbol(alias) {
      const index = this.inventory.indexOf(alias);
      if (index !== -1) {
          this.inventory.splice(index, 1);
          console.log("Removed symbol:", alias, "Inventory:", this.inventory); // Debugging
      } else {
          console.error(`Symbol with alias ${alias} not found in inventory.`);
      }
  }


  addMoney(amount) {
      this.wallet += amount;
      this.updateMoneyDisplay();
  }

  removeMoney(amount) {
      if (this.wallet >= amount) {
          this.wallet -= amount;
          this.updateMoneyDisplay();
          return true;
      }
      return false;
  }

  addBonusItem(item) {
      this.bonusItems.push(item);
  }

  removeBonusItem(item) {
      const index = this.bonusItems.indexOf(item);
      if (index !== -1) {
          this.bonusItems.splice(index, 1);
      }
  }

  updateMoneyDisplay() {
      const moneyDisplay = document.getElementById('moneyDisplay');
      if (moneyDisplay) { // Check if the element exists
          moneyDisplay.textContent = `Money: ${this.wallet}`;
      }
  }
}

export default Player;

================
File: src/scripts/symbol_list.js
================
// src/scripts/symbol_list.js (Example - Expand this!)
import GameSymbol from './gameSymbol.js';

const symbols = {
    cat: new GameSymbol("🐱", "cat", "Friendly feline", 2, 1),       // Base payout 2
    milk: new GameSymbol("🥛", "milk", "Refreshing drink", 1, 1),    // Base payout 1
    dog: new GameSymbol("🐶", "dog", "Loyal companion", 3, 1),       // Base payout 3
    pirate: new GameSymbol("🏴‍☠️", "pirate", "Treasure hunter", 4, 1), // Base payout 4
    treasure: new GameSymbol("💎", "treasure", "Shiny!", 10, 0.5),    // Base payout 10, rarer
    skull: new GameSymbol("💀", "skull", "Spooky!", 0, 0.8),        // Base payout 0!  Needs effects.
     clover: new GameSymbol("🍀", "clover", "Lucky!", 1, .6), //base pay 1,
};

// --- Interactions ---

// Cat drinks milk
symbols.cat.addAdjacencyEffect("milk", "adjacencyDestruction", {});

// Pirate and Dog get along
symbols.pirate.addAdjacencyEffect("dog", "adjacencyBonus", { bonusAmount: 3 });

// Dog likes other dogs
symbols.dog.addGlobalEffect("totalMultiplier", { multiplier: 1 });

// Cats like other cats on the *same row*
symbols.cat.addGlobalEffect("rowMultiplier", { multiplier: 2 });

// Skulls are worth more with more skulls
symbols.skull.addGlobalEffect("totalMultiplier", { multiplier: 1 });

//clovers give a flat bonus to adjacent symbols
symbols.clover.addAdjacencyEffect("cat", "adjacencyBonus", { bonusAmount: 2 });
symbols.clover.addAdjacencyEffect("milk", "adjacencyBonus", { bonusAmount: 2 });
symbols.clover.addAdjacencyEffect("dog", "adjacencyBonus", { bonusAmount: 2 });
symbols.clover.addAdjacencyEffect("pirate", "adjacencyBonus", { bonusAmount: 2 });
symbols.clover.addAdjacencyEffect("treasure", "adjacencyBonus", { bonusAmount: 2 });
symbols.clover.addAdjacencyEffect("skull", "adjacencyBonus", { bonusAmount: 2 });

export default symbols;

================
File: src/styles/slotmachine.css
================
/* General body styling */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    background-color: #BBD0FF; /* Soft blue */
    font-family: Arial, sans-serif;
}

/* Slot machine styling */
.slot-machine {
    text-align: center;
    padding: 20px;
    background: #B8C0FF; /* Deeper blue */
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.status-bar {
    position: fixed; /* or absolute, depending on your layout */
    top: 10px;
    right: 10px;
    background-color: #f0f0f0; /* Light grey background */
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    z-index: 100; /* Make sure it's above other elements */
    color: #333; /* Dark text for readability */
}

.reel-content {
    position: relative;
    height: 120px;
    font-size: 24px; 
    display: flex;
    align-items: center;  
    justify-content: center;  
}
.reel-content .symbol {
    display: block;
    opacity: 1;  
    font-size: 24px;  
}
/* Grid of reels */
.reels {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 10px;
}

.reel {
    overflow: hidden;
    width: 60px;
    height: 60px;
    border: 2px solid gray;
    background: white;
    display: flex;
    justify-content: center;
    align-items: center;
}

.button-container {
    margin-top: 10px;
}

button {
    padding: 10px 20px;
    font-size: 16px;
    background-color: #FFD6FF;
    color: #282c34;
    border: none;
    border-radius: 5px;
}

button:hover {
    background-color: #E7C6FF;
}

#resultDisplay {
    margin-top: 20px;
    padding: 10px;
    font-weight: bold;
    background: #C8B6FF; /* Lavender */
    border-radius: 5px;
}
.symbol {
    display: block;
    opacity: 1;
    font-size: 24px;
}

@keyframes flyToWallet {
    0% {
        transform: translateY(0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translateY(-100px) scale(4.5);
        opacity: 0;
    }
}

.payout {
    position: absolute;
    bottom: 0;
    width: 100%;
    text-align: center;
    color: rgb(90, 87, 38);
    font-size: 16px;
    opacity: 0; /* Start hidden until animated */
    transition: opacity 0.5s ease-in-out; /* Control opacity separately if needed */
}

.fly-to-wallet {
    animation: flyToWallet 2s ease-in-out forwards; /* Use the defined keyframes */
}
/* Add to your existing slotmachine.css */
.symbol-choice {
    font-size: 24px;
    margin: 10px;
    padding: 15px;
    border: 2px solid #C8B6FF;
    background: white;
    border-radius: 10px;
    cursor: pointer;
    transition: transform 0.2s, background-color 0.2s;
}

.symbol-choice:hover {
    transform: scale(1.1);
    background-color: #FFD6FF;
}

.winning-symbol {
    animation: pulse 0.5s ease-in-out;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

.spin-button-disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Enhanced payout animation */
@keyframes flyToWallet {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    50% {
        transform: translate(var(--tx), var(--ty)) scale(1.5);
        opacity: 0.7;
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}

.payout.animate {
    animation: flyToWallet 1s ease-out forwards;
}

/* Symbol interaction visualization */
.interaction-effect {
    position: absolute;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
}

.interaction-active {
    opacity: 1;
}

.slot-machine {
    text-align: center;
    padding: 20px;
    background: #B8C0FF; /* Deeper blue */
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    position: relative; /* Add this */
}
#symbolChoices {
    position: absolute;
    top: 50%; /* Adjust as needed */
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #f0f0f0;
    padding: 20px;
    border: 1px solid #ccc;
    border-radius: 5px;
    z-index: 10; /* Make sure it's above other elements */
    text-align: center; /* Center the buttons */
}

#symbolChoices button {
    margin: 5px; /* Add some spacing between buttons */
    padding: 8px 12px;
    font-size: 14px;
    /* Other styling for buttons */
}

#symbolChoices h2{
    margin: 5px; /* Add some spacing between buttons */
    padding: 8px 12px;
    font-size: 14px;
}
.dollar-animation {
    position: absolute;  /* Crucial for positioning */
    color: green;       /* Or any color you like */
    font-weight: bold;
    user-select: none;   /* Prevent text selection */
    pointer-events: none; /* Make it non-interactive */
    animation: floatUpAndFade 1.5s ease-out forwards; /* Animation details */
    z-index: 5; /* Ensure it's above the symbols, but below symbol choices*/
}

.floating-payout {
    position: absolute; /* Important for positioning */
    color: gold; /* Or whatever color you want */
    font-weight: bold;
    font-size: 20px;
    pointer-events: none; /* So it doesn't block clicks */
    z-index: 100; /* Make sure it's on top */
    transition: transform 2s ease-out, opacity 2s ease-out; /* Animation */
}

@keyframes floatUpAndFade {
    0% {
        transform: translateY(0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translateY(-50px) scale(1.5); /* Adjust as needed */
        opacity: 0;
    }
}
.rent-paid {
    color: green; /* Example styling */
    font-weight: bold;
    animation: rentPaidAnimation 2s ease-out;
}

@keyframes rentPaidAnimation{
    0% {
        transform: scale(1);
        opacity: 1;
    }
    50% {
        transform: scale(1.2);
        opacity: 0.8;
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}
